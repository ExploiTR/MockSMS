package hacks.exploitr.mockSms.helpers;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.net.Uri;
import android.os.Build;
import android.provider.Telephony;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import java.security.SecureRandom;

import hacks.exploitr.mockSms.constants.SMSData;

public class SMSCreator {

	private static String address_internal;
	private static long date_internal;
	private static long date_sent_internal; //todo
	private static int read_internal;
	private static int status_internal;
	private static int type_internal;
	private static int reply_path_present_internal;
	private static String body_internal;
	private static String service_center_internal;
	private static int seen_internal;
	private static int sub_id_internal;

	private static boolean simple_internal;

	private Context mContext;

	SMSCreator(boolean simple) {
		simple_internal = simple;
	}

	public static SMSCreator createSimple(String address,
										  int type,
										  String body) {
		address_internal = address;
		read_internal = 0;
		status_internal = SMSData.STATUS_COMPLETE;
		type_internal = type;
		reply_path_present_internal = 1;
		body_internal = body;
		service_center_internal = getLongRandomForServiceNumber();
		sub_id_internal = 0;
		seen_internal = 0;
		date_internal = System.currentTimeMillis();
		date_sent_internal = System.currentTimeMillis() - (10 * 60 * 1000); //10 min ago

		return new SMSCreator(true);
	}

	public static SMSCreator createAdvanced(String address,
											long date,
											boolean read,
											int status,
											int type,
											boolean reply_path_present,
											boolean seen,
											String body,
											long service_center,
											int sub_id) {

		address_internal = address;
		date_internal = date;
		read_internal = read ? 1 : 0;
		status_internal = status;
		type_internal = type;
		reply_path_present_internal = reply_path_present ? 1 : 0;
		body_internal = body;
		service_center_internal = String.valueOf(service_center);
		sub_id_internal = sub_id;
		seen_internal = seen ? 1 : 0;

		return new SMSCreator(false);
	}

	public void save(AppCompatActivity context, SMSListener listener) {
		mContext = context;
		try {
			if (Build.VERSION.SDK_INT >= 26) {
				new SMSCreatorKTExecute()
						.doWork(sub_id_internal,
								address_internal, body_internal,
								date_internal);
				listener.onCompleted(true);
			} else {
				ContentValues values = returnContentValues();
				ContentResolver resolver = context.getContentResolver();
				Uri uri = Telephony.Sms.Inbox.CONTENT_URI;
				if (resolver != null && uri != null)
					resolver.insert(uri, values);
				else {
					listener.onCompleted(false);
					return;
				}
				listener.onCompleted(true);
			}
		} catch (Exception ex) {
			ex.printStackTrace();
			listener.onCompleted(false);
		}
	}


	@NonNull
	private ContentValues returnContentValues() {
		ContentValues values = new ContentValues();
		//Address
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
			values.put(Telephony.Sms.THREAD_ID, Telephony.Threads.getOrCreateThreadId(mContext, address_internal));
		}
		values.put(SMSData.ADDRESS, address_internal);
		values.put(SMSData.BODY, body_internal);
		values.put(SMSData.DATE_SENT, date_sent_internal);
		values.put(SMSData.READ, read_internal);
		values.put(SMSData.SEEN, seen_internal);
		values.put(SMSData.TYPE, type_internal);

		boolean slot_enabled = simple_internal || SMSDb.getInstance(mContext).isSLOT_ENABLED();

		if (slot_enabled) {
			if (Build.BRAND.contains("Samsung") | Build.BRAND.contains("samsung")) {
				values.put(SMSData.SIM_SLOT_SAMSUNG, sub_id_internal);
				if (SMSDb.getInstance(mContext).isIMSI_ENABLED()) {
					values.put(SMSData.SIM_IMSI_SAMSUNG, SMSDb.getInstance(mContext).getSimImsi());
				}
			}
			values.put(SMSData.SUB_SLOT_LYF, SMSDb.getInstance(mContext).getSimSlot());
			values.put(SMSData.SIM_SLOT_SAMSUNG, sub_id_internal);
		}
		if (simple_internal || SMSDb.getInstance(mContext).isREPLY_PATH_PRESENT()) {
			values.put(SMSData.REPLY_PATH_PRESENT, reply_path_present_internal);
		}
		if (simple_internal || SMSDb.getInstance(mContext).isServiceCenterBool()) {
			values.put(SMSData.SERVICE_CENTER, service_center_internal);
		}

		values.put(SMSData.DATE_SENT, date_internal);

		if (type_internal != SMSData.MESSAGE_TYPE_SENT) {
			values.put(SMSData.STATUS, status_internal);
			if (SMSDb.getInstance(mContext).isDelivered()) {
				values.put(SMSData.DELIVERED, 1);
			}
		}

		return values;
	}

	private static String getLongRandomForServiceNumber() {
		return "+" + Math.abs((long) new SecureRandom().nextInt(100) * 1234 * 80000);
	}

	public interface SMSListener {
		void onCompleted(boolean success);
	}

	/*
	*     override fun buildObservable(params: Params): Flowable<*> {
        return Flowable.just(params)
                .filter { it.messages.isNotEmpty() }
                .mapNotNull {
                    // Don't continue if the sender is blocked
                    val messages = it.messages
                    val address = messages[0].displayOriginatingAddress
                    val action = blockingClient.getAction(address).blockingGet()
                    val shouldDrop = prefs.drop.get()
                    Timber.v("block=$action, drop=$shouldDrop")

                    // If we should drop the message, don't even save it
                    if (action is BlockingClient.Action.Block && shouldDrop) {
                        return@mapNotNull null
                    }

                    val time = messages[0].timestampMillis
                    val body: String = messages
                            .mapNotNull { message -> message.displayMessageBody }
                            .reduce { body, new -> body + new }

                    // Add the message to the db
                    val message = messageRepo.insertReceivedSms(it.subId, address, body, time)

                    when (action) {
                        is BlockingClient.Action.Block -> {
                            messageRepo.markRead(message.threadId)
                            conversationRepo.markBlocked(listOf(message.threadId), prefs.blockingManager.get(), action.reason)
                        }
                        is BlockingClient.Action.Unblock -> conversationRepo.markUnblocked(message.threadId)
                        else -> Unit
                    }

                    message
                }
                .doOnNext { message ->
                    conversationRepo.updateConversations(message.threadId) // Update the conversation
                }
                .mapNotNull { message ->
                    conversationRepo.getOrCreateConversation(message.threadId) // Map message to conversation
                }
                .filter { conversation -> !conversation.blocked } // Don't notify for blocked conversations
                .doOnNext { conversation ->
                    // Unarchive conversation if necessary
                    if (conversation.archived) conversationRepo.markUnarchived(conversation.id)
                }
                .map { conversation -> conversation.id } // Map to the id because [delay] will put us on the wrong thread
                .doOnNext { threadId -> notificationManager.update(threadId) } // Update the notification
                .doOnNext { shortcutManager.updateShortcuts() } // Update shortcuts
                .flatMap { updateBadge.buildObservable(Unit) } // Update the badge and widget
    }
    *
    *
    *     @Inject lateinit var receiveMessage: ReceiveSms

    override fun onReceive(context: Context, intent: Intent) {
        AndroidInjection.inject(this, context)
        Timber.v("onReceive")

        Sms.Intents.getMessagesFromIntent(intent)?.let { messages ->
            val subId = intent.extras?.getInt("subscription", -1) ?: -1

            val pendingResult = goAsync()
            receiveMessage.execute(ReceiveSms.Params(subId, messages)) { pendingResult.finish() }
        }
    }
	*
	* */
}
